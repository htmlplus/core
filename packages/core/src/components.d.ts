/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { AspectRatioValue } from "./components/aspect-ratio/aspect-ratio.types";
import { DialogFullscreen, DialogPlacement, DialogSize } from "./components/dialog/dialog/dialog.types";
import { DrawerBackdrop, DrawerBreakpoint, DrawerPlacement } from "./components/drawer/drawer/drawer.types";
import { GridAlignContent, GridAlignItems, GridGutter, GridJustifyContent, GridWrap } from "./components/grid/grid/grid.types";
import { GridItemAlignSelf, GridItemColumn, GridItemOffset, GridItemOrder } from "./components/grid/grid-item/grid-item.types";
import { IntersectionBehavior } from "./components/intersection/intersection.types";
import { MenuAlignX, MenuAlignY, MenuGrowX, MenuGrowY } from "./components/menu/menu.types";
import { SpinnerSize, SpinnerType } from "./components/spinner/spinner.types";
import { TransitionDirection, TransitionDuration, TransitionPause, TransitionRepeat, TransitionStart } from "./components/transition/transition.types";
import { SubscribeType } from "./services/tunnel/tunnel.types";
export namespace Components {
    interface PlusAspectRatio {
        /**
          * Specifies the ratio.
         */
        "value"?: AspectRatioValue;
    }
    interface PlusCard {
        /**
          * TODO
         */
        "tile"?: boolean;
    }
    interface PlusCardBody {
    }
    interface PlusCardFooter {
    }
    interface PlusCardHeader {
    }
    interface PlusDialog {
        /**
          * Activate the dialog's backdrop to show or not.
         */
        "backdrop"?: boolean;
        /**
          * This property helps you to attach which dialog toggler controls the dialog.  It doesn't matter where the dialog toggler is.  You can put the dialog's toggler inside or outside of the dialog.  Read more about connectors [here](https://htmlplus.io/features/connector).
         */
        "connector"?: string;
        /**
          * Set the height of the dialog as much as the screen's height.
         */
        "fullHeight"?: boolean;
        /**
          * Set the width of the dialog as much as the screen's width.
         */
        "fullWidth"?: boolean;
        /**
          * Set both width and height of the dialog to occupy the screen size.
         */
        "fullscreen"?: DialogFullscreen;
        /**
          * Closes the dialog when `escape` key is pressed.
         */
        "keyboard"?: boolean;
        /**
          * Control dialog to show or not.
         */
        "open"?: boolean;
        /**
          * It prevents the dialog from closing on clicking outside of the element.
         */
        "persistent"?: boolean;
        /**
          * Specifies where to show the dialog box by choosing two values, one for horizontal and another for vertical. Horizontal has a range of `left`, `center`, `right`, `start`, `end`, and vertical values are `top`, `center` and `bottom`.
         */
        "placement"?: DialogPlacement;
        /**
          * It makes the user able to scroll the content by adding a scroll beside it.
         */
        "scrollable"?: boolean;
        /**
          * Determine the width of the dialog.
         */
        "size"?: DialogSize;
        /**
          * Removes the margin around the dialog's content.
         */
        "sticky"?: boolean;
    }
    interface PlusDialogBody {
        /**
          * It makes the user able to scroll the content by adding a scroll beside it.
         */
        "scrollable"?: boolean;
    }
    interface PlusDialogContent {
        /**
          * It makes the user able to scroll the content by adding a scroll beside it.
         */
        "scrollable"?: boolean;
    }
    interface PlusDialogFooter {
    }
    interface PlusDialogHeader {
    }
    interface PlusDialogToggler {
        /**
          * This property helps you to attach which dialog this toggler controls.  It doesn't matter where the dialog toggler is.  You can put the dialog's toggler inside or outside of the dialog.  Read more about connectors [here](https://htmlplus.io/features/connector).
         */
        "connector"?: string;
    }
    interface PlusDrawer {
        /**
          * Activate the drawer's backdrop to show or not.
         */
        "backdrop"?: DrawerBackdrop;
        /**
          * Sets the mobile breakpoint to apply alternate styles for mobile devices when the breakpoint value is met.
         */
        "breakpoint"?: DrawerBreakpoint;
        /**
          * This property helps you to attach which drawer toggler controls the drawer.  It doesn't matter where the drawer toggler is.  You can put the drawer's toggler inside or outside of the drawer.  Read more about connectors [here](https://htmlplus.io/features/connector).
         */
        "connector"?: string;
        /**
          * It controls the flexibility of the drawer's width. If yes, the width of the drawer can be reduced. If false doesn't allow the width of the drawer to reduce.
         */
        "flexible"?: boolean;
        /**
          * Set the width of drawer to the minimum size you specified for the `mini-size` property.
         */
        "mini"?: boolean;
        /**
          * Sets the minimum width size of the drawer.
         */
        "miniSize"?: string;
        /**
          * Control drawer to show or not.
         */
        "open"?: boolean;
        /**
          * If true, don't allow the drawer to be closed by clicking outside of the drawer. If false, the drawer will be closed by clicking outside of it.
         */
        "persistent"?: boolean;
        /**
          * Specifies where the drawer will open.
         */
        "placement"?: DrawerPlacement;
        /**
          * Determine the width of the drawer.
         */
        "size"?: string;
        /**
          * On default the drawer is considered as a part of the main container. it pushes the other contents on opening. If true it will be opened over other contents and doesn't affect other contents. A temporary drawer sits above its application and uses a backdrop to darken the background.
         */
        "temporary"?: boolean;
    }
    interface PlusDrawerToggler {
        /**
          * This property helps you to attach which drawer this toggler controls.  It doesn't matter where the drawer toggler is.  You can put the drawer's toggler inside or outside of the drawer.  Read more about connectors [here](https://htmlplus.io/features/connector).
         */
        "connector"?: string;
    }
    interface PlusGrid {
        /**
          * Aligns contents vertically across all rows (It overrides alignItems).
         */
        "alignContent"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for large display sizes (It overrides alignItemsLg).
         */
        "alignContentLg"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for medium display sizes (It overrides alignItemsMd).
         */
        "alignContentMd"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for small display sizes (It overrides alignItemsSm).
         */
        "alignContentSm"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for extra-large display sizes (It overrides alignItemsXl).
         */
        "alignContentXl"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for extra-small display sizes (It overrides alignItemsXs).
         */
        "alignContentXs"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for extra-extra-large display sizes (It overrides alignItemsXXl).
         */
        "alignContentXxl"?: GridAlignContent;
        /**
          * Aligns contents vertically inside their own row.
         */
        "alignItems"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for large display sizes.
         */
        "alignItemsLg"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for medium display sizes.
         */
        "alignItemsMd"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for small display sizes.
         */
        "alignItemsSm"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for extra-large display sizes.
         */
        "alignItemsXl"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for extra-small display sizes.
         */
        "alignItemsXs"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for extra-extra-large display sizes.
         */
        "alignItemsXxl"?: GridAlignItems;
        /**
          * Adds a gap between contents to make space between them vertically and horizontally.
         */
        "gutter"?: GridGutter;
        /**
          * Adds a gap between contents to make space between them horizontally.
         */
        "gutterX"?: GridGutter;
        /**
          * Adds a gap between contents to make space between them vertically.
         */
        "gutterY"?: GridGutter;
        /**
          * Justifies contents horizontally.
         */
        "justifyContent"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for large display sizes.
         */
        "justifyContentLg"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for medium display sizes.
         */
        "justifyContentMd"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for small display sizes.
         */
        "justifyContentSm"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for extra-large display sizes.
         */
        "justifyContentXl"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for extra-small display sizes.
         */
        "justifyContentXs"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for extra-extra-large display sizes.
         */
        "justifyContentXxl"?: GridJustifyContent;
        /**
          * Reverses the flow of contents from left-to-right to right-to-left, or vice-versa.
         */
        "reverse"?: boolean;
        /**
          * Changes the flow of contents from left-to-right to top-to-down.
         */
        "vertical"?: boolean;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width.
         */
        "wrap"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for large screen devices.
         */
        "wrapLg"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for medium screen devices.
         */
        "wrapMd"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for small screen devices.
         */
        "wrapSm"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for extra-large screen devices.
         */
        "wrapXl"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for extra-small screen devices.
         */
        "wrapXs"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for extra-extra-large screen devices.
         */
        "wrapXxl"?: GridWrap;
    }
    interface PlusGridItem {
        /**
          * Aligns the grid-item vertically in its container (grid). It overrides the align-items property of its parent.
         */
        "alignSelf"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for large display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for large breakpoints).
         */
        "alignSelfLg"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for medium display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for medium breakpoints).
         */
        "alignSelfMd"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for small display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for small breakpoints).
         */
        "alignSelfSm"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for extra-large display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for extra-large breakpoints).
         */
        "alignSelfXl"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for extra-small display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for extra-small breakpoints).
         */
        "alignSelfXs"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for extra-extra-large display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for extra-extra-large breakpoints).
         */
        "alignSelfXxl"?: GridItemAlignSelf;
        /**
          * Hides the grid-item in all display sizes.
         */
        "hide"?: boolean;
        /**
          * Hides the grid-item in large display sizes (desktop).
         */
        "hideLg"?: boolean;
        /**
          * Hides the grid-item in large and smaller display sizes.
         */
        "hideLgDown"?: boolean;
        /**
          * Hides the grid-item in large and larger display sizes.
         */
        "hideLgUp"?: boolean;
        /**
          * Hides the grid-item in medium display sizes (tablets).
         */
        "hideMd"?: boolean;
        /**
          * Hides the grid-item in medium and smaller display sizes.
         */
        "hideMdDown"?: boolean;
        /**
          * Hides the grid-item in medium and larger display sizes.
         */
        "hideMdUp"?: boolean;
        /**
          * Hides the grid-item in small display sizes (landscape phones).
         */
        "hideSm"?: boolean;
        /**
          * Hides the grid-item in small and smaller display sizes.
         */
        "hideSmDown"?: boolean;
        /**
          * Hides the grid-item in small and larger display sizes.
         */
        "hideSmUp"?: boolean;
        /**
          * Hides the grid-item in extra-large display sizes (large desktops).
         */
        "hideXl"?: boolean;
        /**
          * Hides the grid-item in large and smaller display sizes.
         */
        "hideXlDown"?: boolean;
        /**
          * Hides the grid-item in large and larger display sizes.
         */
        "hideXlUp"?: boolean;
        /**
          * Hides the grid-item in extra-small display sizes (portrait phones).
         */
        "hideXs"?: boolean;
        /**
          * Hides the grid-item in extra-extra-large display sizes (larger desktops).
         */
        "hideXxl"?: boolean;
        /**
          * Hides the grid-item in large and smaller display sizes.
         */
        "hideXxlDown"?: boolean;
        /**
          * Specifies the number of columns for large viewports (desktop). It also determines the number of columns for bigger display sizes when the upper breakpoint (xl and xxl) is not specified.
         */
        "lg"?: GridItemColumn;
        /**
          * Specifies the number of columns for medium viewports (tablets). It also determines the number of columns for bigger display sizes when other upper breakpoints (lg, xl and xxl) are not specified.
         */
        "md"?: GridItemColumn;
        /**
          * Adds an offset space before the grid-item for large display sizes. It also applies to the larger breakpoint (xl) while that is not specified.
         */
        "offsetLg"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for medium display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "offsetMd"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for small display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "offsetSm"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for extra-large display sizes.
         */
        "offsetXl"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for extra-small display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "offsetXs"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for extra-extra-large display sizes.
         */
        "offsetXxl"?: GridItemOffset;
        /**
          * Overrides the default order of the grid-item for large display sizes. It also applies to the larger breakpoint (xl) while that is not specified.
         */
        "orderLg"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for medium display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "orderMd"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for small display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "orderSm"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for extra-large display sizes.
         */
        "orderXl"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for extra-small display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "orderXs"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for extra-extra-large display sizes.
         */
        "orderXxl"?: GridItemOrder;
        /**
          * Specifies the number of columns for small viewports (landscape phones). It also determines the number of columns for bigger display sizes when other upper breakpoints (md, lg, xl and xxl) are not specified.
         */
        "sm"?: GridItemColumn;
        /**
          * Specifies the number of columns for large viewports (large desktops). It also determines the number of columns for bigger display sizes when the upper breakpoint (xxl) is not specified.
         */
        "xl"?: GridItemColumn;
        /**
          * Specifies the number of columns for extra-small viewports (portrait phones). It also determines the number of columns for bigger display sizes when other upper breakpoints (sm, md, lg, xl and xxl) are not specified.
         */
        "xs"?: GridItemColumn;
        /**
          * Specifies the number of columns for extra-extra-large viewports (larger desktops).
         */
        "xxl"?: GridItemColumn;
    }
    interface PlusIntersection {
        /**
          * It specifies how intersection behaves with its children.  When it's set to `normal`, it doesn't have any effect on its children and the life cycles happen normally. When it's set to `blink` the children are removed from the DOM when the element intersects with the viewport and are brought back in the DOM immediately. With that said, it affects the life cycles of its children. When it's set to `appear` the children are removed from the first moment, and then they're brought back in when the element intersects with the viewport. In other words, the children are added to the DOM when the element intersects with the viewport and they are removed when the element leaves the viewport.
         */
        "behavior"?: IntersectionBehavior;
        /**
          * Disables the intersection's trigger.
         */
        "disabled"?: boolean;
        /**
          * It causes the callback to be called just once for the first time.
         */
        "once"?: boolean;
        /**
          * The element that is used as the viewport for checking visibility of the target. Must be the ancestor of the target.  Defaults to the browser viewport if not specified or if null.
         */
        "root"?: Element;
        /**
          * Margin around the root. Can have values similar to the CSS [margin](https://developer.mozilla.org/en-US/docs/Web/CSS/margin) property, e.g.  "10px 20px 30px 40px" (top, right, bottom, left). The values can be percentages.  This set of values serves to grow or shrink each side of the root element's bounding box before computing intersections.  Defaults to all zeros.
         */
        "rootMargin"?: string;
        /**
          * Either a single number or an array of numbers which indicate at what percentage of the target's visibility the observer's callback should be executed.  If you only want to detect when visibility passes the 50% mark, you can use a value of 0.5.  If you want the callback to run every time visibility passes another 25%, you would specify the array [0, 0.25, 0.5, 0.75, 1].  The default is 0 (meaning as soon as even one pixel is visible, the callback will be run).  A value of 1.0 means that the threshold isn't considered passed until every pixel is visible.
         */
        "threshold"?: number | number[];
    }
    interface PlusMenu {
        /**
          * TODO
         */
        "alignX"?: MenuAlignX;
        /**
          * TODO
         */
        "alignY"?: MenuAlignY;
        /**
          * TODO
         */
        "fixed"?: boolean;
        /**
          * TODO
         */
        "growX"?: MenuGrowX;
        /**
          * TODO
         */
        "growY"?: MenuGrowY;
        /**
          * TODO
         */
        "offsetX"?: string | number;
        /**
          * TODO
         */
        "offsetY"?: string | number;
        /**
          * TODO
         */
        "open"?: boolean;
        /**
          * TODO
         */
        "persistent"?: boolean;
        /**
          * TODO
         */
        "trigger"?: 'click' | 'hover';
    }
    interface PlusOutsideClick {
        /**
          * TODO
         */
        "disabled"?: boolean;
        /**
          * TODO
         */
        "once"?: boolean;
    }
    interface PlusRipple {
    }
    interface PlusSpinner {
        /**
          * Specifies the size of the spinner.
         */
        "size"?: SpinnerSize;
        /**
          * Specifies which variant of the spinner to use.
         */
        "type"?: SpinnerType;
    }
    interface PlusSwitch {
        /**
          * Puts the switch in checked state
         */
        "checked"?: boolean;
        /**
          * Disables the switch
         */
        "disabled"?: boolean;
        /**
          * Change the appearance of the switch to put the text inside the switch
         */
        "inset"?: boolean;
        /**
          * Switches the location of yes and no options
         */
        "reverse"?: boolean;
    }
    interface PlusTabs {
        /**
          * TODO
         */
        "connector"?: string;
        /**
          * TODO
         */
        "value"?: string;
        /**
          * TODO
         */
        "vertical"?: boolean;
    }
    interface PlusTabsBar {
        /**
          * TODO
         */
        "grow"?: boolean;
        /**
          * TODO
         */
        "justify"?: 'start' | 'center' | 'end';
        /**
          * TODO
         */
        "reverse"?: boolean;
    }
    interface PlusTabsPanel {
        /**
          * TODO
         */
        "value"?: string;
    }
    interface PlusTabsPanels {
        /**
          * TODO
         */
        "connector"?: string;
    }
    interface PlusTabsTab {
        /**
          * TODO
         */
        "disabled"?: boolean;
        /**
          * TODO
         */
        "value"?: string;
    }
    interface PlusTransition {
        /**
          * TODO
         */
        "delay"?: string;
        /**
          * TODO
         */
        "direction"?: TransitionDirection;
        /**
          * TODO
         */
        "duration"?: TransitionDuration;
        /**
          * TODO
         */
        "name": string;
        /**
          * TODO
         */
        "pause"?: TransitionPause;
        /**
          * TODO
         */
        "repeat"?: TransitionRepeat;
        /**
          * TODO
         */
        "start"?: TransitionStart;
    }
    interface PlusTunnelConsumer {
        "context": { [key: string]: any };
        "renderer": Function;
        "subscribe"?: SubscribeType;
    }
}
declare global {
    interface HTMLPlusAspectRatioElement extends Components.PlusAspectRatio, HTMLStencilElement {
    }
    var HTMLPlusAspectRatioElement: {
        prototype: HTMLPlusAspectRatioElement;
        new (): HTMLPlusAspectRatioElement;
    };
    interface HTMLPlusCardElement extends Components.PlusCard, HTMLStencilElement {
    }
    var HTMLPlusCardElement: {
        prototype: HTMLPlusCardElement;
        new (): HTMLPlusCardElement;
    };
    interface HTMLPlusCardBodyElement extends Components.PlusCardBody, HTMLStencilElement {
    }
    var HTMLPlusCardBodyElement: {
        prototype: HTMLPlusCardBodyElement;
        new (): HTMLPlusCardBodyElement;
    };
    interface HTMLPlusCardFooterElement extends Components.PlusCardFooter, HTMLStencilElement {
    }
    var HTMLPlusCardFooterElement: {
        prototype: HTMLPlusCardFooterElement;
        new (): HTMLPlusCardFooterElement;
    };
    interface HTMLPlusCardHeaderElement extends Components.PlusCardHeader, HTMLStencilElement {
    }
    var HTMLPlusCardHeaderElement: {
        prototype: HTMLPlusCardHeaderElement;
        new (): HTMLPlusCardHeaderElement;
    };
    interface HTMLPlusDialogElement extends Components.PlusDialog, HTMLStencilElement {
    }
    var HTMLPlusDialogElement: {
        prototype: HTMLPlusDialogElement;
        new (): HTMLPlusDialogElement;
    };
    interface HTMLPlusDialogBodyElement extends Components.PlusDialogBody, HTMLStencilElement {
    }
    var HTMLPlusDialogBodyElement: {
        prototype: HTMLPlusDialogBodyElement;
        new (): HTMLPlusDialogBodyElement;
    };
    interface HTMLPlusDialogContentElement extends Components.PlusDialogContent, HTMLStencilElement {
    }
    var HTMLPlusDialogContentElement: {
        prototype: HTMLPlusDialogContentElement;
        new (): HTMLPlusDialogContentElement;
    };
    interface HTMLPlusDialogFooterElement extends Components.PlusDialogFooter, HTMLStencilElement {
    }
    var HTMLPlusDialogFooterElement: {
        prototype: HTMLPlusDialogFooterElement;
        new (): HTMLPlusDialogFooterElement;
    };
    interface HTMLPlusDialogHeaderElement extends Components.PlusDialogHeader, HTMLStencilElement {
    }
    var HTMLPlusDialogHeaderElement: {
        prototype: HTMLPlusDialogHeaderElement;
        new (): HTMLPlusDialogHeaderElement;
    };
    interface HTMLPlusDialogTogglerElement extends Components.PlusDialogToggler, HTMLStencilElement {
    }
    var HTMLPlusDialogTogglerElement: {
        prototype: HTMLPlusDialogTogglerElement;
        new (): HTMLPlusDialogTogglerElement;
    };
    interface HTMLPlusDrawerElement extends Components.PlusDrawer, HTMLStencilElement {
    }
    var HTMLPlusDrawerElement: {
        prototype: HTMLPlusDrawerElement;
        new (): HTMLPlusDrawerElement;
    };
    interface HTMLPlusDrawerTogglerElement extends Components.PlusDrawerToggler, HTMLStencilElement {
    }
    var HTMLPlusDrawerTogglerElement: {
        prototype: HTMLPlusDrawerTogglerElement;
        new (): HTMLPlusDrawerTogglerElement;
    };
    interface HTMLPlusGridElement extends Components.PlusGrid, HTMLStencilElement {
    }
    var HTMLPlusGridElement: {
        prototype: HTMLPlusGridElement;
        new (): HTMLPlusGridElement;
    };
    interface HTMLPlusGridItemElement extends Components.PlusGridItem, HTMLStencilElement {
    }
    var HTMLPlusGridItemElement: {
        prototype: HTMLPlusGridItemElement;
        new (): HTMLPlusGridItemElement;
    };
    interface HTMLPlusIntersectionElement extends Components.PlusIntersection, HTMLStencilElement {
    }
    var HTMLPlusIntersectionElement: {
        prototype: HTMLPlusIntersectionElement;
        new (): HTMLPlusIntersectionElement;
    };
    interface HTMLPlusMenuElement extends Components.PlusMenu, HTMLStencilElement {
    }
    var HTMLPlusMenuElement: {
        prototype: HTMLPlusMenuElement;
        new (): HTMLPlusMenuElement;
    };
    interface HTMLPlusOutsideClickElement extends Components.PlusOutsideClick, HTMLStencilElement {
    }
    var HTMLPlusOutsideClickElement: {
        prototype: HTMLPlusOutsideClickElement;
        new (): HTMLPlusOutsideClickElement;
    };
    interface HTMLPlusRippleElement extends Components.PlusRipple, HTMLStencilElement {
    }
    var HTMLPlusRippleElement: {
        prototype: HTMLPlusRippleElement;
        new (): HTMLPlusRippleElement;
    };
    interface HTMLPlusSpinnerElement extends Components.PlusSpinner, HTMLStencilElement {
    }
    var HTMLPlusSpinnerElement: {
        prototype: HTMLPlusSpinnerElement;
        new (): HTMLPlusSpinnerElement;
    };
    interface HTMLPlusSwitchElement extends Components.PlusSwitch, HTMLStencilElement {
    }
    var HTMLPlusSwitchElement: {
        prototype: HTMLPlusSwitchElement;
        new (): HTMLPlusSwitchElement;
    };
    interface HTMLPlusTabsElement extends Components.PlusTabs, HTMLStencilElement {
    }
    var HTMLPlusTabsElement: {
        prototype: HTMLPlusTabsElement;
        new (): HTMLPlusTabsElement;
    };
    interface HTMLPlusTabsBarElement extends Components.PlusTabsBar, HTMLStencilElement {
    }
    var HTMLPlusTabsBarElement: {
        prototype: HTMLPlusTabsBarElement;
        new (): HTMLPlusTabsBarElement;
    };
    interface HTMLPlusTabsPanelElement extends Components.PlusTabsPanel, HTMLStencilElement {
    }
    var HTMLPlusTabsPanelElement: {
        prototype: HTMLPlusTabsPanelElement;
        new (): HTMLPlusTabsPanelElement;
    };
    interface HTMLPlusTabsPanelsElement extends Components.PlusTabsPanels, HTMLStencilElement {
    }
    var HTMLPlusTabsPanelsElement: {
        prototype: HTMLPlusTabsPanelsElement;
        new (): HTMLPlusTabsPanelsElement;
    };
    interface HTMLPlusTabsTabElement extends Components.PlusTabsTab, HTMLStencilElement {
    }
    var HTMLPlusTabsTabElement: {
        prototype: HTMLPlusTabsTabElement;
        new (): HTMLPlusTabsTabElement;
    };
    interface HTMLPlusTransitionElement extends Components.PlusTransition, HTMLStencilElement {
    }
    var HTMLPlusTransitionElement: {
        prototype: HTMLPlusTransitionElement;
        new (): HTMLPlusTransitionElement;
    };
    interface HTMLPlusTunnelConsumerElement extends Components.PlusTunnelConsumer, HTMLStencilElement {
    }
    var HTMLPlusTunnelConsumerElement: {
        prototype: HTMLPlusTunnelConsumerElement;
        new (): HTMLPlusTunnelConsumerElement;
    };
    interface HTMLElementTagNameMap {
        "plus-aspect-ratio": HTMLPlusAspectRatioElement;
        "plus-card": HTMLPlusCardElement;
        "plus-card-body": HTMLPlusCardBodyElement;
        "plus-card-footer": HTMLPlusCardFooterElement;
        "plus-card-header": HTMLPlusCardHeaderElement;
        "plus-dialog": HTMLPlusDialogElement;
        "plus-dialog-body": HTMLPlusDialogBodyElement;
        "plus-dialog-content": HTMLPlusDialogContentElement;
        "plus-dialog-footer": HTMLPlusDialogFooterElement;
        "plus-dialog-header": HTMLPlusDialogHeaderElement;
        "plus-dialog-toggler": HTMLPlusDialogTogglerElement;
        "plus-drawer": HTMLPlusDrawerElement;
        "plus-drawer-toggler": HTMLPlusDrawerTogglerElement;
        "plus-grid": HTMLPlusGridElement;
        "plus-grid-item": HTMLPlusGridItemElement;
        "plus-intersection": HTMLPlusIntersectionElement;
        "plus-menu": HTMLPlusMenuElement;
        "plus-outside-click": HTMLPlusOutsideClickElement;
        "plus-ripple": HTMLPlusRippleElement;
        "plus-spinner": HTMLPlusSpinnerElement;
        "plus-switch": HTMLPlusSwitchElement;
        "plus-tabs": HTMLPlusTabsElement;
        "plus-tabs-bar": HTMLPlusTabsBarElement;
        "plus-tabs-panel": HTMLPlusTabsPanelElement;
        "plus-tabs-panels": HTMLPlusTabsPanelsElement;
        "plus-tabs-tab": HTMLPlusTabsTabElement;
        "plus-transition": HTMLPlusTransitionElement;
        "plus-tunnel-consumer": HTMLPlusTunnelConsumerElement;
    }
}
declare namespace LocalJSX {
    interface PlusAspectRatio {
        /**
          * Specifies the ratio.
         */
        "value"?: AspectRatioValue;
    }
    interface PlusCard {
        /**
          * TODO
         */
        "tile"?: boolean;
    }
    interface PlusCardBody {
    }
    interface PlusCardFooter {
    }
    interface PlusCardHeader {
    }
    interface PlusDialog {
        /**
          * Activate the dialog's backdrop to show or not.
         */
        "backdrop"?: boolean;
        /**
          * This property helps you to attach which dialog toggler controls the dialog.  It doesn't matter where the dialog toggler is.  You can put the dialog's toggler inside or outside of the dialog.  Read more about connectors [here](https://htmlplus.io/features/connector).
         */
        "connector"?: string;
        /**
          * Set the height of the dialog as much as the screen's height.
         */
        "fullHeight"?: boolean;
        /**
          * Set the width of the dialog as much as the screen's width.
         */
        "fullWidth"?: boolean;
        /**
          * Set both width and height of the dialog to occupy the screen size.
         */
        "fullscreen"?: DialogFullscreen;
        /**
          * Closes the dialog when `escape` key is pressed.
         */
        "keyboard"?: boolean;
        /**
          * When the dialog is going to hide
         */
        "onPlusClose"?: (event: CustomEvent<void>) => void;
        /**
          * When the dialog is completely closed and its animation is completed.
         */
        "onPlusClosed"?: (event: CustomEvent<void>) => void;
        /**
          * When the dialog is going to show this event triggers
         */
        "onPlusOpen"?: (event: CustomEvent<void>) => void;
        /**
          * When the dialog is completely shown and its animation is completed.
         */
        "onPlusOpened"?: (event: CustomEvent<void>) => void;
        /**
          * Control dialog to show or not.
         */
        "open"?: boolean;
        /**
          * It prevents the dialog from closing on clicking outside of the element.
         */
        "persistent"?: boolean;
        /**
          * Specifies where to show the dialog box by choosing two values, one for horizontal and another for vertical. Horizontal has a range of `left`, `center`, `right`, `start`, `end`, and vertical values are `top`, `center` and `bottom`.
         */
        "placement"?: DialogPlacement;
        /**
          * It makes the user able to scroll the content by adding a scroll beside it.
         */
        "scrollable"?: boolean;
        /**
          * Determine the width of the dialog.
         */
        "size"?: DialogSize;
        /**
          * Removes the margin around the dialog's content.
         */
        "sticky"?: boolean;
    }
    interface PlusDialogBody {
        /**
          * It makes the user able to scroll the content by adding a scroll beside it.
         */
        "scrollable"?: boolean;
    }
    interface PlusDialogContent {
        /**
          * It makes the user able to scroll the content by adding a scroll beside it.
         */
        "scrollable"?: boolean;
    }
    interface PlusDialogFooter {
    }
    interface PlusDialogHeader {
    }
    interface PlusDialogToggler {
        /**
          * This property helps you to attach which dialog this toggler controls.  It doesn't matter where the dialog toggler is.  You can put the dialog's toggler inside or outside of the dialog.  Read more about connectors [here](https://htmlplus.io/features/connector).
         */
        "connector"?: string;
    }
    interface PlusDrawer {
        /**
          * Activate the drawer's backdrop to show or not.
         */
        "backdrop"?: DrawerBackdrop;
        /**
          * Sets the mobile breakpoint to apply alternate styles for mobile devices when the breakpoint value is met.
         */
        "breakpoint"?: DrawerBreakpoint;
        /**
          * This property helps you to attach which drawer toggler controls the drawer.  It doesn't matter where the drawer toggler is.  You can put the drawer's toggler inside or outside of the drawer.  Read more about connectors [here](https://htmlplus.io/features/connector).
         */
        "connector"?: string;
        /**
          * It controls the flexibility of the drawer's width. If yes, the width of the drawer can be reduced. If false doesn't allow the width of the drawer to reduce.
         */
        "flexible"?: boolean;
        /**
          * Set the width of drawer to the minimum size you specified for the `mini-size` property.
         */
        "mini"?: boolean;
        /**
          * Sets the minimum width size of the drawer.
         */
        "miniSize"?: string;
        /**
          * When the drawer is going to hide
         */
        "onPlusClose"?: (event: CustomEvent<void>) => void;
        /**
          * When the drawer is completely closed and its animation is completed.
         */
        "onPlusClosed"?: (event: CustomEvent<void>) => void;
        /**
          * When the drawer is going to show this event triggers
         */
        "onPlusOpen"?: (event: CustomEvent<void>) => void;
        /**
          * When the drawer is completely shown and its animation is completed.
         */
        "onPlusOpened"?: (event: CustomEvent<void>) => void;
        /**
          * Control drawer to show or not.
         */
        "open"?: boolean;
        /**
          * If true, don't allow the drawer to be closed by clicking outside of the drawer. If false, the drawer will be closed by clicking outside of it.
         */
        "persistent"?: boolean;
        /**
          * Specifies where the drawer will open.
         */
        "placement"?: DrawerPlacement;
        /**
          * Determine the width of the drawer.
         */
        "size"?: string;
        /**
          * On default the drawer is considered as a part of the main container. it pushes the other contents on opening. If true it will be opened over other contents and doesn't affect other contents. A temporary drawer sits above its application and uses a backdrop to darken the background.
         */
        "temporary"?: boolean;
    }
    interface PlusDrawerToggler {
        /**
          * This property helps you to attach which drawer this toggler controls.  It doesn't matter where the drawer toggler is.  You can put the drawer's toggler inside or outside of the drawer.  Read more about connectors [here](https://htmlplus.io/features/connector).
         */
        "connector"?: string;
    }
    interface PlusGrid {
        /**
          * Aligns contents vertically across all rows (It overrides alignItems).
         */
        "alignContent"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for large display sizes (It overrides alignItemsLg).
         */
        "alignContentLg"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for medium display sizes (It overrides alignItemsMd).
         */
        "alignContentMd"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for small display sizes (It overrides alignItemsSm).
         */
        "alignContentSm"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for extra-large display sizes (It overrides alignItemsXl).
         */
        "alignContentXl"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for extra-small display sizes (It overrides alignItemsXs).
         */
        "alignContentXs"?: GridAlignContent;
        /**
          * Aligns contents vertically across all rows for extra-extra-large display sizes (It overrides alignItemsXXl).
         */
        "alignContentXxl"?: GridAlignContent;
        /**
          * Aligns contents vertically inside their own row.
         */
        "alignItems"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for large display sizes.
         */
        "alignItemsLg"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for medium display sizes.
         */
        "alignItemsMd"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for small display sizes.
         */
        "alignItemsSm"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for extra-large display sizes.
         */
        "alignItemsXl"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for extra-small display sizes.
         */
        "alignItemsXs"?: GridAlignItems;
        /**
          * Aligns contents vertically inside their own row for extra-extra-large display sizes.
         */
        "alignItemsXxl"?: GridAlignItems;
        /**
          * Adds a gap between contents to make space between them vertically and horizontally.
         */
        "gutter"?: GridGutter;
        /**
          * Adds a gap between contents to make space between them horizontally.
         */
        "gutterX"?: GridGutter;
        /**
          * Adds a gap between contents to make space between them vertically.
         */
        "gutterY"?: GridGutter;
        /**
          * Justifies contents horizontally.
         */
        "justifyContent"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for large display sizes.
         */
        "justifyContentLg"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for medium display sizes.
         */
        "justifyContentMd"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for small display sizes.
         */
        "justifyContentSm"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for extra-large display sizes.
         */
        "justifyContentXl"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for extra-small display sizes.
         */
        "justifyContentXs"?: GridJustifyContent;
        /**
          * Justifies contents horizontally for extra-extra-large display sizes.
         */
        "justifyContentXxl"?: GridJustifyContent;
        /**
          * Reverses the flow of contents from left-to-right to right-to-left, or vice-versa.
         */
        "reverse"?: boolean;
        /**
          * Changes the flow of contents from left-to-right to top-to-down.
         */
        "vertical"?: boolean;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width.
         */
        "wrap"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for large screen devices.
         */
        "wrapLg"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for medium screen devices.
         */
        "wrapMd"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for small screen devices.
         */
        "wrapSm"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for extra-large screen devices.
         */
        "wrapXl"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for extra-small screen devices.
         */
        "wrapXs"?: GridWrap;
        /**
          * Controls allowing the container to wrap the content or not if the cumulative width size of contents is more than the twelve-column width for extra-extra-large screen devices.
         */
        "wrapXxl"?: GridWrap;
    }
    interface PlusGridItem {
        /**
          * Aligns the grid-item vertically in its container (grid). It overrides the align-items property of its parent.
         */
        "alignSelf"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for large display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for large breakpoints).
         */
        "alignSelfLg"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for medium display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for medium breakpoints).
         */
        "alignSelfMd"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for small display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for small breakpoints).
         */
        "alignSelfSm"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for extra-large display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for extra-large breakpoints).
         */
        "alignSelfXl"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for extra-small display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for extra-small breakpoints).
         */
        "alignSelfXs"?: GridItemAlignSelf;
        /**
          * Aligns the grid-item vertically in its container (grid) for extra-extra-large display sizes. It also applies to larger breakpoints and display sizes while they are not specified. (It overrides the align-items property of its parent just for extra-extra-large breakpoints).
         */
        "alignSelfXxl"?: GridItemAlignSelf;
        /**
          * Hides the grid-item in all display sizes.
         */
        "hide"?: boolean;
        /**
          * Hides the grid-item in large display sizes (desktop).
         */
        "hideLg"?: boolean;
        /**
          * Hides the grid-item in large and smaller display sizes.
         */
        "hideLgDown"?: boolean;
        /**
          * Hides the grid-item in large and larger display sizes.
         */
        "hideLgUp"?: boolean;
        /**
          * Hides the grid-item in medium display sizes (tablets).
         */
        "hideMd"?: boolean;
        /**
          * Hides the grid-item in medium and smaller display sizes.
         */
        "hideMdDown"?: boolean;
        /**
          * Hides the grid-item in medium and larger display sizes.
         */
        "hideMdUp"?: boolean;
        /**
          * Hides the grid-item in small display sizes (landscape phones).
         */
        "hideSm"?: boolean;
        /**
          * Hides the grid-item in small and smaller display sizes.
         */
        "hideSmDown"?: boolean;
        /**
          * Hides the grid-item in small and larger display sizes.
         */
        "hideSmUp"?: boolean;
        /**
          * Hides the grid-item in extra-large display sizes (large desktops).
         */
        "hideXl"?: boolean;
        /**
          * Hides the grid-item in large and smaller display sizes.
         */
        "hideXlDown"?: boolean;
        /**
          * Hides the grid-item in large and larger display sizes.
         */
        "hideXlUp"?: boolean;
        /**
          * Hides the grid-item in extra-small display sizes (portrait phones).
         */
        "hideXs"?: boolean;
        /**
          * Hides the grid-item in extra-extra-large display sizes (larger desktops).
         */
        "hideXxl"?: boolean;
        /**
          * Hides the grid-item in large and smaller display sizes.
         */
        "hideXxlDown"?: boolean;
        /**
          * Specifies the number of columns for large viewports (desktop). It also determines the number of columns for bigger display sizes when the upper breakpoint (xl and xxl) is not specified.
         */
        "lg"?: GridItemColumn;
        /**
          * Specifies the number of columns for medium viewports (tablets). It also determines the number of columns for bigger display sizes when other upper breakpoints (lg, xl and xxl) are not specified.
         */
        "md"?: GridItemColumn;
        /**
          * Adds an offset space before the grid-item for large display sizes. It also applies to the larger breakpoint (xl) while that is not specified.
         */
        "offsetLg"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for medium display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "offsetMd"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for small display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "offsetSm"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for extra-large display sizes.
         */
        "offsetXl"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for extra-small display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "offsetXs"?: GridItemOffset;
        /**
          * Adds an offset space before the grid-item for extra-extra-large display sizes.
         */
        "offsetXxl"?: GridItemOffset;
        /**
          * Overrides the default order of the grid-item for large display sizes. It also applies to the larger breakpoint (xl) while that is not specified.
         */
        "orderLg"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for medium display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "orderMd"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for small display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "orderSm"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for extra-large display sizes.
         */
        "orderXl"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for extra-small display sizes. It also applies to larger breakpoints and display sizes while they are not specified.
         */
        "orderXs"?: GridItemOrder;
        /**
          * Overrides the default order of the grid-item for extra-extra-large display sizes.
         */
        "orderXxl"?: GridItemOrder;
        /**
          * Specifies the number of columns for small viewports (landscape phones). It also determines the number of columns for bigger display sizes when other upper breakpoints (md, lg, xl and xxl) are not specified.
         */
        "sm"?: GridItemColumn;
        /**
          * Specifies the number of columns for large viewports (large desktops). It also determines the number of columns for bigger display sizes when the upper breakpoint (xxl) is not specified.
         */
        "xl"?: GridItemColumn;
        /**
          * Specifies the number of columns for extra-small viewports (portrait phones). It also determines the number of columns for bigger display sizes when other upper breakpoints (sm, md, lg, xl and xxl) are not specified.
         */
        "xs"?: GridItemColumn;
        /**
          * Specifies the number of columns for extra-extra-large viewports (larger desktops).
         */
        "xxl"?: GridItemColumn;
    }
    interface PlusIntersection {
        /**
          * It specifies how intersection behaves with its children.  When it's set to `normal`, it doesn't have any effect on its children and the life cycles happen normally. When it's set to `blink` the children are removed from the DOM when the element intersects with the viewport and are brought back in the DOM immediately. With that said, it affects the life cycles of its children. When it's set to `appear` the children are removed from the first moment, and then they're brought back in when the element intersects with the viewport. In other words, the children are added to the DOM when the element intersects with the viewport and they are removed when the element leaves the viewport.
         */
        "behavior"?: IntersectionBehavior;
        /**
          * Disables the intersection's trigger.
         */
        "disabled"?: boolean;
        /**
          * This event is triggered when its children intersects with the viewport in either coming to the viewport or going out of it.
         */
        "onPlusChange"?: (event: CustomEvent<IntersectionObserverEntry>) => void;
        /**
          * It causes the callback to be called just once for the first time.
         */
        "once"?: boolean;
        /**
          * The element that is used as the viewport for checking visibility of the target. Must be the ancestor of the target.  Defaults to the browser viewport if not specified or if null.
         */
        "root"?: Element;
        /**
          * Margin around the root. Can have values similar to the CSS [margin](https://developer.mozilla.org/en-US/docs/Web/CSS/margin) property, e.g.  "10px 20px 30px 40px" (top, right, bottom, left). The values can be percentages.  This set of values serves to grow or shrink each side of the root element's bounding box before computing intersections.  Defaults to all zeros.
         */
        "rootMargin"?: string;
        /**
          * Either a single number or an array of numbers which indicate at what percentage of the target's visibility the observer's callback should be executed.  If you only want to detect when visibility passes the 50% mark, you can use a value of 0.5.  If you want the callback to run every time visibility passes another 25%, you would specify the array [0, 0.25, 0.5, 0.75, 1].  The default is 0 (meaning as soon as even one pixel is visible, the callback will be run).  A value of 1.0 means that the threshold isn't considered passed until every pixel is visible.
         */
        "threshold"?: number | number[];
    }
    interface PlusMenu {
        /**
          * TODO
         */
        "alignX"?: MenuAlignX;
        /**
          * TODO
         */
        "alignY"?: MenuAlignY;
        /**
          * TODO
         */
        "fixed"?: boolean;
        /**
          * TODO
         */
        "growX"?: MenuGrowX;
        /**
          * TODO
         */
        "growY"?: MenuGrowY;
        /**
          * TODO
         */
        "offsetX"?: string | number;
        /**
          * TODO
         */
        "offsetY"?: string | number;
        /**
          * TODO
         */
        "onPlusClose"?: (event: CustomEvent<any>) => void;
        /**
          * TODO
         */
        "open"?: boolean;
        /**
          * TODO
         */
        "persistent"?: boolean;
        /**
          * TODO
         */
        "trigger"?: 'click' | 'hover';
    }
    interface PlusOutsideClick {
        /**
          * TODO
         */
        "disabled"?: boolean;
        /**
          * TODO
         */
        "onPlusOutsideClick"?: (event: CustomEvent<any>) => void;
        /**
          * TODO
         */
        "once"?: boolean;
    }
    interface PlusRipple {
    }
    interface PlusSpinner {
        /**
          * Specifies the size of the spinner.
         */
        "size"?: SpinnerSize;
        /**
          * Specifies which variant of the spinner to use.
         */
        "type"?: SpinnerType;
    }
    interface PlusSwitch {
        /**
          * Puts the switch in checked state
         */
        "checked"?: boolean;
        /**
          * Disables the switch
         */
        "disabled"?: boolean;
        /**
          * Change the appearance of the switch to put the text inside the switch
         */
        "inset"?: boolean;
        /**
          * When the switch state is changed this event triggers.
         */
        "onPlusChange"?: (event: CustomEvent<void>) => void;
        /**
          * Switches the location of yes and no options
         */
        "reverse"?: boolean;
    }
    interface PlusTabs {
        /**
          * TODO
         */
        "connector"?: string;
        /**
          * TODO
         */
        "onWowChange"?: (event: CustomEvent<any>) => void;
        /**
          * TODO
         */
        "value"?: string;
        /**
          * TODO
         */
        "vertical"?: boolean;
    }
    interface PlusTabsBar {
        /**
          * TODO
         */
        "grow"?: boolean;
        /**
          * TODO
         */
        "justify"?: 'start' | 'center' | 'end';
        /**
          * TODO
         */
        "reverse"?: boolean;
    }
    interface PlusTabsPanel {
        /**
          * TODO
         */
        "value"?: string;
    }
    interface PlusTabsPanels {
        /**
          * TODO
         */
        "connector"?: string;
    }
    interface PlusTabsTab {
        /**
          * TODO
         */
        "disabled"?: boolean;
        /**
          * TODO
         */
        "value"?: string;
    }
    interface PlusTransition {
        /**
          * TODO
         */
        "delay"?: string;
        /**
          * TODO
         */
        "direction"?: TransitionDirection;
        /**
          * TODO
         */
        "duration"?: TransitionDuration;
        /**
          * TODO
         */
        "name"?: string;
        /**
          * TODO
         */
        "onPlusCancel"?: (event: CustomEvent<any>) => void;
        /**
          * TODO
         */
        "onPlusEnd"?: (event: CustomEvent<any>) => void;
        /**
          * TODO
         */
        "onPlusIteration"?: (event: CustomEvent<any>) => void;
        /**
          * TODO
         */
        "onPlusStart"?: (event: CustomEvent<any>) => void;
        /**
          * TODO
         */
        "pause"?: TransitionPause;
        /**
          * TODO
         */
        "repeat"?: TransitionRepeat;
        /**
          * TODO
         */
        "start"?: TransitionStart;
    }
    interface PlusTunnelConsumer {
        "context"?: { [key: string]: any };
        "renderer"?: Function;
        "subscribe"?: SubscribeType;
    }
    interface IntrinsicElements {
        "plus-aspect-ratio": PlusAspectRatio;
        "plus-card": PlusCard;
        "plus-card-body": PlusCardBody;
        "plus-card-footer": PlusCardFooter;
        "plus-card-header": PlusCardHeader;
        "plus-dialog": PlusDialog;
        "plus-dialog-body": PlusDialogBody;
        "plus-dialog-content": PlusDialogContent;
        "plus-dialog-footer": PlusDialogFooter;
        "plus-dialog-header": PlusDialogHeader;
        "plus-dialog-toggler": PlusDialogToggler;
        "plus-drawer": PlusDrawer;
        "plus-drawer-toggler": PlusDrawerToggler;
        "plus-grid": PlusGrid;
        "plus-grid-item": PlusGridItem;
        "plus-intersection": PlusIntersection;
        "plus-menu": PlusMenu;
        "plus-outside-click": PlusOutsideClick;
        "plus-ripple": PlusRipple;
        "plus-spinner": PlusSpinner;
        "plus-switch": PlusSwitch;
        "plus-tabs": PlusTabs;
        "plus-tabs-bar": PlusTabsBar;
        "plus-tabs-panel": PlusTabsPanel;
        "plus-tabs-panels": PlusTabsPanels;
        "plus-tabs-tab": PlusTabsTab;
        "plus-transition": PlusTransition;
        "plus-tunnel-consumer": PlusTunnelConsumer;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "plus-aspect-ratio": LocalJSX.PlusAspectRatio & JSXBase.HTMLAttributes<HTMLPlusAspectRatioElement>;
            "plus-card": LocalJSX.PlusCard & JSXBase.HTMLAttributes<HTMLPlusCardElement>;
            "plus-card-body": LocalJSX.PlusCardBody & JSXBase.HTMLAttributes<HTMLPlusCardBodyElement>;
            "plus-card-footer": LocalJSX.PlusCardFooter & JSXBase.HTMLAttributes<HTMLPlusCardFooterElement>;
            "plus-card-header": LocalJSX.PlusCardHeader & JSXBase.HTMLAttributes<HTMLPlusCardHeaderElement>;
            "plus-dialog": LocalJSX.PlusDialog & JSXBase.HTMLAttributes<HTMLPlusDialogElement>;
            "plus-dialog-body": LocalJSX.PlusDialogBody & JSXBase.HTMLAttributes<HTMLPlusDialogBodyElement>;
            "plus-dialog-content": LocalJSX.PlusDialogContent & JSXBase.HTMLAttributes<HTMLPlusDialogContentElement>;
            "plus-dialog-footer": LocalJSX.PlusDialogFooter & JSXBase.HTMLAttributes<HTMLPlusDialogFooterElement>;
            "plus-dialog-header": LocalJSX.PlusDialogHeader & JSXBase.HTMLAttributes<HTMLPlusDialogHeaderElement>;
            "plus-dialog-toggler": LocalJSX.PlusDialogToggler & JSXBase.HTMLAttributes<HTMLPlusDialogTogglerElement>;
            "plus-drawer": LocalJSX.PlusDrawer & JSXBase.HTMLAttributes<HTMLPlusDrawerElement>;
            "plus-drawer-toggler": LocalJSX.PlusDrawerToggler & JSXBase.HTMLAttributes<HTMLPlusDrawerTogglerElement>;
            "plus-grid": LocalJSX.PlusGrid & JSXBase.HTMLAttributes<HTMLPlusGridElement>;
            "plus-grid-item": LocalJSX.PlusGridItem & JSXBase.HTMLAttributes<HTMLPlusGridItemElement>;
            "plus-intersection": LocalJSX.PlusIntersection & JSXBase.HTMLAttributes<HTMLPlusIntersectionElement>;
            "plus-menu": LocalJSX.PlusMenu & JSXBase.HTMLAttributes<HTMLPlusMenuElement>;
            "plus-outside-click": LocalJSX.PlusOutsideClick & JSXBase.HTMLAttributes<HTMLPlusOutsideClickElement>;
            "plus-ripple": LocalJSX.PlusRipple & JSXBase.HTMLAttributes<HTMLPlusRippleElement>;
            "plus-spinner": LocalJSX.PlusSpinner & JSXBase.HTMLAttributes<HTMLPlusSpinnerElement>;
            "plus-switch": LocalJSX.PlusSwitch & JSXBase.HTMLAttributes<HTMLPlusSwitchElement>;
            "plus-tabs": LocalJSX.PlusTabs & JSXBase.HTMLAttributes<HTMLPlusTabsElement>;
            "plus-tabs-bar": LocalJSX.PlusTabsBar & JSXBase.HTMLAttributes<HTMLPlusTabsBarElement>;
            "plus-tabs-panel": LocalJSX.PlusTabsPanel & JSXBase.HTMLAttributes<HTMLPlusTabsPanelElement>;
            "plus-tabs-panels": LocalJSX.PlusTabsPanels & JSXBase.HTMLAttributes<HTMLPlusTabsPanelsElement>;
            "plus-tabs-tab": LocalJSX.PlusTabsTab & JSXBase.HTMLAttributes<HTMLPlusTabsTabElement>;
            "plus-transition": LocalJSX.PlusTransition & JSXBase.HTMLAttributes<HTMLPlusTransitionElement>;
            "plus-tunnel-consumer": LocalJSX.PlusTunnelConsumer & JSXBase.HTMLAttributes<HTMLPlusTunnelConsumerElement>;
        }
    }
}
