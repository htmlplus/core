{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nconst PARAM_REGEX = /^\\[(.+)\\]$/;\nexport class Router {\n  constructor(BASE_URL = '') {\n    this.BASE_URL = BASE_URL;\n\n    _defineProperty(this, \"routes\", []);\n  }\n\n  createQueryStringUrl(query = {}) {\n    return Object.keys(query).filter(key => query[key]).map(key => `${key}=${query[key]}`).join('&');\n  }\n\n  joinQueryString(url, qs) {\n    return `${url}${qs ? `?${qs}` : ''}`;\n  }\n\n  getParsed(name) {\n    return this.routes.find(item => item.name === name);\n  }\n\n  register(name, route) {\n    const parsed = route.path.split('/').filter(part => part !== '/' && !!part).map(part => {\n      const parameter = PARAM_REGEX.exec(part); // if this part is a route parameter\n\n      if (parameter) {\n        let regex = '(\\\\/[^\\\\/#\\\\?]*)'; // is an array route parameter\n\n        const isArray = parameter[1].includes('...');\n\n        if (isArray) {\n          regex += '+?';\n        }\n\n        return {\n          regex,\n          param: parameter[1].replace('...', ''),\n          full: part,\n          isArray\n        };\n      }\n\n      return {\n        regex: `(\\\\/${part})`\n      };\n    }).reduce((result, part) => {\n      const output = _objectSpread(_objectSpread({}, result), {}, {\n        parts: [...result.parts, part],\n        regex: result.regex + part.regex\n      });\n\n      if (part.param) {\n        output.params = [...output.params, part.param];\n      }\n\n      return output;\n    }, {\n      name,\n      options: route,\n      parts: [],\n      params: [],\n      regex: '^'\n    });\n    this.routes.push(_objectSpread(_objectSpread({}, parsed), {}, {\n      regex: new RegExp(parsed.parts.length > 0 ? `${parsed.regex}([\\\\?#].*)?$` : '^\\\\/([\\\\?#].*)?$')\n    }));\n  }\n\n  al() {\n    return this.routes;\n  }\n\n  get(name) {\n    return (this.getParsed(name) || {}).options;\n  }\n\n  href(name, query) {\n    const route = this.get(name);\n\n    if (route) {\n      const qs = typeof query === 'string' ? query : this.createQueryStringUrl(query);\n      return this.joinQueryString(route.path, qs);\n    }\n  }\n\n  path(name, params, query) {\n    const route = this.getParsed(name);\n\n    if (!route) {\n      return;\n    }\n\n    const pathWithoutQuery = route.parts.filter(item => !!item.param).reduce((result = '', {\n      full = '',\n      param,\n      isArray\n    }) => {\n      if (!params || !params[param || '']) {\n        return result;\n      }\n\n      return result.replace(full, Array.isArray(params[param]) ? params[param].join('/') : params[param]);\n    }, route.options.path);\n    const qs = this.createQueryStringUrl(query);\n    return this.joinQueryString(pathWithoutQuery, qs);\n  }\n\n  getByUrl(url = '') {\n    let href = url.replace(this.BASE_URL, '');\n\n    if (href[href.length - 1] === '/') {\n      href = href.slice(0, href.length - 2);\n    }\n\n    if (href === undefined || href === '') {\n      href = '/';\n    }\n\n    const hrefParts = href.split('/').filter(part => part !== '/' && !!part);\n    const route = this.routes.find(item => item.regex.test(href));\n\n    if (route) {\n      const params = route.regex.exec(href).slice(1).map((item, index, allItems) => {\n        if (route.parts[index] && route.parts[index].param) {\n          if (route.parts[index].isArray) {\n            return {\n              param: route.parts[index].param,\n              value: hrefParts.slice(index, hrefParts.length - allItems.length - 1)\n            };\n          }\n\n          return {\n            param: route.parts[index].param,\n            value: item.replace('/', '')\n          };\n        }\n      }).filter(item => !!item);\n      return {\n        name: route.name,\n        params\n      };\n    }\n\n    return undefined;\n  }\n\n}","map":{"version":3,"sources":["C:/projects/mine/htmlplus/core/packages/docs/src/services/router/router.ts"],"names":["PARAM_REGEX","Router","constructor","BASE_URL","createQueryStringUrl","query","Object","keys","filter","key","map","join","joinQueryString","url","qs","getParsed","name","routes","find","item","register","route","parsed","path","split","part","parameter","exec","regex","isArray","includes","param","replace","full","reduce","result","output","parts","params","options","push","RegExp","length","al","get","href","pathWithoutQuery","Array","getByUrl","slice","undefined","hrefParts","test","index","allItems","value"],"mappings":"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","sourcesContent":["const PARAM_REGEX = /^\\[(.+)\\]$/;\n\ninterface RouteOptions {\n  path: string;\n  [key: string]: any;\n}\n\ninterface RoutePart {\n  regex: string;\n  param?: string;\n  full?: string;\n  isArray?: boolean;\n}\n\ninterface RouteParameter {\n  param: string;\n  value?: string | string[];\n}\n\ninterface ParsedRoute {\n  name: string;\n  options: RouteOptions;\n  parts: RoutePart[];\n  params: string[];\n  regex: RegExp;\n}\n\nexport class Router {\n  private readonly routes: ParsedRoute[] = [];\n\n  constructor(private readonly BASE_URL: string = '') {}\n\n  private createQueryStringUrl(query: { [key: string]: any } = {}) {\n    return Object.keys(query)\n      .filter((key) => query[key])\n      .map((key) => `${key}=${query[key]}`)\n      .join('&');\n  }\n\n  private joinQueryString(url: string, qs?: string) {\n    return `${url}${qs ? `?${qs}` : ''}`;\n  }\n\n  private getParsed(name: string) {\n    return this.routes.find((item) => item.name === name);\n  }\n\n  register(name: string, route: RouteOptions): void {\n    const parsed = route.path\n      .split('/')\n      .filter((part) => part !== '/' && !!part)\n      .map((part) => {\n        const parameter = PARAM_REGEX.exec(part);\n\n        // if this part is a route parameter\n        if (parameter) {\n          let regex = '(\\\\/[^\\\\/#\\\\?]*)';\n\n          // is an array route parameter\n          const isArray = parameter[1].includes('...');\n\n          if (isArray) {\n            regex += '+?';\n          }\n\n          return {\n            regex,\n            param: parameter[1].replace('...', ''),\n            full: part,\n            isArray,\n          };\n        }\n\n        return {\n          regex: `(\\\\/${part})`,\n        };\n      })\n      .reduce<Omit<ParsedRoute, 'regex'> & { regex: string }>(\n        (result, part) => {\n          const output = {\n            ...result,\n            parts: [...result.parts, part],\n            regex: result.regex + part.regex,\n          };\n\n          if (part.param) {\n            output.params = [...output.params, part.param];\n          }\n\n          return output;\n        },\n        { name, options: route, parts: [], params: [], regex: '^' },\n      );\n\n    this.routes.push({\n      ...parsed,\n      regex: new RegExp(\n        parsed.parts.length > 0 ? `${parsed.regex}([\\\\?#].*)?$` : '^\\\\/([\\\\?#].*)?$',\n      ),\n    });\n  }\n\n  al() {\n    return this.routes;\n  }\n\n  get(name: string): RouteOptions | undefined {\n    return (this.getParsed(name) || {}).options;\n  }\n\n  href(name: string, query?: object | string): string | undefined {\n    const route = this.get(name);\n    if (route) {\n      const qs = typeof query === 'string' ? query : this.createQueryStringUrl(query);\n\n      return this.joinQueryString(route.path, qs);\n    }\n  }\n\n  path(name: string, params?: object, query?: object): string | undefined {\n    const route = this.getParsed(name);\n\n    if (!route) {\n      return;\n    }\n\n    const pathWithoutQuery = route.parts\n      .filter((item) => !!item.param)\n      .reduce<string>((result = '', { full = '', param, isArray }) => {\n        if (!params || !params[param || '']) {\n          return result;\n        }\n        return result.replace(\n          full,\n          Array.isArray(params[param]) ? params[param].join('/') : params[param],\n        );\n      }, route.options.path);\n\n    const qs = this.createQueryStringUrl(query);\n\n    return this.joinQueryString(pathWithoutQuery, qs);\n  }\n\n  getByUrl(url: string = ''): { name: string; params: RouteParameter[] } | undefined {\n    let href = url.replace(this.BASE_URL, '');\n    if (href[href.length - 1] === '/') {\n      href = href.slice(0, href.length - 2);\n    }\n    if (href === undefined || href === '') {\n      href = '/';\n    }\n    const hrefParts = href.split('/').filter((part) => part !== '/' && !!part);\n\n    const route = this.routes.find((item) => item.regex.test(href));\n\n    if (route) {\n      const params = route.regex\n        .exec(href)\n        .slice(1)\n        .map((item, index, allItems) => {\n          if (route.parts[index] && route.parts[index].param) {\n            if (route.parts[index].isArray) {\n              return {\n                param: route.parts[index].param,\n                value: hrefParts.slice(index, hrefParts.length - allItems.length - 1),\n              };\n            }\n\n            return {\n              param: route.parts[index].param,\n              value: item.replace('/', ''),\n            };\n          }\n        })\n        .filter((item) => !!item);\n\n      return {\n        name: route.name,\n        params,\n      };\n    }\n\n    return undefined;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}