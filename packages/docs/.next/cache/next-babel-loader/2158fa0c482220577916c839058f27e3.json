{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst PARAM_REGEX = /^\\[(.+)\\]$/;\nexport class Router {\n  constructor(BASE_URL = '') {\n    this.BASE_URL = BASE_URL;\n\n    _defineProperty(this, \"routes\", []);\n  }\n\n  createQueryStringUrl(query = {}) {\n    return Object.keys(query).filter(key => query[key]).map(key => `${key}=${query[key]}`).join('&');\n  }\n\n  joinQueryString(url, qs) {\n    return `${url}${qs ? `?${qs}` : ''}`;\n  }\n\n  getParsed(name) {\n    return this.routes.find(item => item.name === name);\n  }\n\n  register(name, route) {\n    const parsed = route.path.split('/').filter(part => part !== '/' && !!part).map(part => {\n      const parameter = PARAM_REGEX.exec(part); // if this part is a route parameter\n\n      if (parameter) {\n        let regex = '(\\\\/[^\\\\/#\\\\?]*)'; // is an array route parameter\n\n        const isArray = parameter[1].includes('...');\n\n        if (isArray) {\n          regex += '+?';\n        }\n\n        return {\n          regex,\n          param: parameter[1].replace('...', ''),\n          full: part,\n          isArray\n        };\n      }\n\n      return {\n        regex: `(\\\\/${part})`\n      };\n    }).reduce((result, part) => {\n      const output = _objectSpread(_objectSpread({}, result), {}, {\n        parts: [...result.parts, part],\n        regex: result.regex + part.regex\n      });\n\n      if (part.param) {\n        output.params = [...output.params, part.param];\n      }\n\n      return output;\n    }, {\n      name,\n      options: route,\n      parts: [],\n      params: [],\n      regex: '^'\n    });\n    this.routes.push(_objectSpread(_objectSpread({}, parsed), {}, {\n      regex: new RegExp(parsed.parts.length > 0 ? `${parsed.regex}([\\\\?#].*)?$` : '^\\\\/([\\\\?#].*)?$')\n    }));\n  }\n\n  al() {\n    return this.routes;\n  }\n\n  get(name) {\n    return (this.getParsed(name) || {}).options;\n  }\n\n  href(name, query) {\n    const route = this.get(name);\n\n    if (route) {\n      const qs = typeof query === 'string' ? query : this.createQueryStringUrl(query);\n      return this.joinQueryString(route.path, qs);\n    }\n  }\n\n  path(name, params, query) {\n    const route = this.getParsed(name);\n\n    if (!route) {\n      return;\n    }\n\n    const pathWithoutQuery = route.parts.filter(item => !!item.param).reduce((result = '', {\n      full = '',\n      param,\n      isArray\n    }) => {\n      if (!params || !params[param || '']) {\n        return result;\n      }\n\n      return result.replace(full, Array.isArray(params[param]) ? params[param].join('/') : params[param]);\n    }, route.options.path);\n    const qs = this.createQueryStringUrl(query);\n    return this.joinQueryString(pathWithoutQuery, qs);\n  }\n\n  getByUrl(url = '') {\n    let href = url.replace(this.BASE_URL, '');\n\n    if (href[href.length - 1] === '/') {\n      href = href.slice(0, href.length - 2);\n    }\n\n    if (href === undefined || href === '') {\n      href = '/';\n    }\n\n    const hrefParts = href.split('/').filter(part => part !== '/' && !!part);\n    const route = this.routes.find(item => item.regex.test(href));\n\n    if (route) {\n      const params = route.regex.exec(href).slice(1).map((item, index, allItems) => {\n        if (route.parts[index] && route.parts[index].param) {\n          if (route.parts[index].isArray) {\n            return {\n              param: route.parts[index].param,\n              value: hrefParts.slice(index, hrefParts.length - allItems.length - 1)\n            };\n          }\n\n          return {\n            param: route.parts[index].param,\n            value: item.replace('/', '')\n          };\n        }\n      }).filter(item => !!item);\n      return {\n        name: route.name,\n        params\n      };\n    }\n\n    return undefined;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}