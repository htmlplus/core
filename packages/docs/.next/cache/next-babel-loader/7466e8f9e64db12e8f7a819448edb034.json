{"ast":null,"code":"import React from 'react';\nimport { Alert, Link, Text } from 'components';\nimport { lexer } from 'marked';\nconst mapper = {\n  blockquote: {\n    name: () => Alert,\n    props: {\n      type: input => {\n        const text = (input.text || '').trim();\n        const types = ['[ERROR]', '[INFO]', '[SUCCESS]', '[WARNING]'];\n\n        for (let i = 0; i < types.length; i++) {\n          const type = types[i];\n          if (text.indexOf(type) === -1) continue;\n          input.text = text.replace(type, '').trim();\n          delete input.tokens;\n          return type.replace(/\\[|\\]/g, '').toLowerCase();\n        }\n      }\n    }\n  },\n  codespan: {\n    name: () => Text,\n    props: {\n      // TODO: set background color to error\n      inline: true,\n      size: 'body'\n    }\n  },\n  heading: {\n    name: () => Text,\n    props: {\n      size: input => {\n        return ['header', 'title', 'body', 'body', 'body', 'body'][input.depth - 1];\n      }\n    }\n  },\n  link: {\n    name: () => Link,\n    props: {\n      href: input => input.href\n    }\n  },\n  paragraph: {\n    name: () => Text,\n    props: {\n      size: 'body'\n    }\n  }\n};\n\nconst convert = input => {\n  if (Array.isArray(input)) {\n    return input.map(item => convert(item));\n  } else {\n    if (input.type === 'text') return input.text;\n    const map = mapper[input.type];\n    if (!map) return console.error(`[MARKUP]: '${input.type}' type not available, raw is '${input.raw}'`);\n    const props = {\n      key: Math.random()\n    };\n    Object.keys(map.props || {}).forEach(key => {\n      try {\n        props[key] = map.props[key](input);\n      } catch {\n        props[key] = map.props[key];\n      }\n    });\n    const children = [];\n    (input.tokens || []).map(item => children.push(convert(item)));\n    return /*#__PURE__*/React.createElement(map.name(), props, children.length ? children : input.text);\n  }\n};\n\nexport const parser = input => {\n  const tokens = Array.from(lexer(input));\n  return convert(tokens);\n};","map":{"version":3,"sources":["C:/projects/mine/htmlplus/core/packages/docs/src/components/markup/markup.parser.ts"],"names":["React","Alert","Link","Text","lexer","mapper","blockquote","name","props","type","input","text","trim","types","i","length","indexOf","replace","tokens","toLowerCase","codespan","inline","size","heading","depth","link","href","paragraph","convert","Array","isArray","map","item","console","error","raw","key","Math","random","Object","keys","forEach","children","push","createElement","parser","from"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { Alert, Link, Text } from 'components';\nimport { lexer } from 'marked';\n\nconst mapper: any = {\n  blockquote: {\n    name: () => Alert,\n    props: {\n      type: (input: any) => {\n\n        const text = (input.text || '').trim();\n\n        const types = ['[ERROR]', '[INFO]', '[SUCCESS]', '[WARNING]'];\n\n        for (let i = 0; i < types.length; i++) {\n\n          const type = types[i];\n\n          if (text.indexOf(type) === -1) continue;\n\n          input.text = text.replace(type, '').trim();\n\n          delete input.tokens;\n\n          return type.replace(/\\[|\\]/g, '').toLowerCase();\n        }\n      },\n    },\n  },\n  codespan: {\n    name: () => Text,\n    props: {\n      // TODO: set background color to error\n      inline: true,\n      size: 'body'\n    },\n  },\n  heading: {\n    name: () => Text,\n    props: {\n      size: (input: any) => {\n        return ['header', 'title', 'body', 'body', 'body', 'body'][input.depth - 1];\n      }\n    },\n  },\n  link: {\n    name: () => Link,\n    props: {\n      href: (input: any) => input.href\n    },\n  },\n  paragraph: {\n    name: () => Text,\n    props: {\n      size: 'body',\n    },\n  },\n};\n\nconst convert = (input: any) => {\n\n  if (Array.isArray(input)) {\n\n    return input.map((item) => convert(item));\n  }\n  else {\n\n    if (input.type === 'text') return input.text;\n\n    const map = mapper[input.type];\n\n    if (!map) return console.error(`[MARKUP]: '${input.type}' type not available, raw is '${input.raw}'`);\n\n    const props = {\n      key: Math.random()\n    };\n\n    Object.keys(map.props || {})\n      .forEach((key) => {\n\n        try {\n\n          props[key] = map.props[key](input);\n        }\n        catch {\n\n          props[key] = map.props[key]\n        }\n      });\n\n    const children: Array<React.ReactNode> = [];\n\n    (input.tokens || []).map((item) => children.push(convert(item)));\n\n    return React.createElement(map.name(), props, children.length ? children : input.text);\n  }\n};\n\nexport const parser = (input: any) => {\n\n  const tokens = Array.from(lexer(input));\n\n  return convert(tokens);\n};\n"]},"metadata":{},"sourceType":"module"}